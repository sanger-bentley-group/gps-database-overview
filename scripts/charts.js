// Selection Animation Transition Time for All Charts
const selectTransitTime = 100;


// Build donut charts in Summary View
function buildDonutChart(data, group) {
    const container = document.querySelector(`#summary-view-${group}-chart`);

    // Set dimension of the chart
    const diameter = 500;
    const radius = diameter / 2;

    // Prepare data for d3.js consumption
    let dataArr = [];

    for (const key in data) {
        // Comment out below line to include unknown data
        if (key === "NaN") { continue; }

        dataArr.push({ key: key !== "NaN" ? key : "Unknown" , value: data[key] });
    }

    // Select svg container
    const svgContainer = d3.select(container);
    
    // Add svg into container
    const svg = svgContainer.append("svg")
        .attr("viewBox", `0 0 ${diameter} ${diameter}`);
    
    // Add chart area in svg
    const chart = svg.append("g")
        .attr("transform", `translate(${radius},${radius})`);

    // Setup color scale
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    
    // Pie generator
    const pieGenerator = d3.pie().value((d) => d.value);
    
    // Data of arcs generated by pie generator
    const arcData = pieGenerator(dataArr);

    // Arc generator
    const arcGenerator = d3.arc()
        .innerRadius(radius * 0.7)
        .outerRadius(radius);

    // Interpolate from start angle to end angle of the pieGenerator
    const angleInterpolate = d3.interpolate(pieGenerator.startAngle()(), pieGenerator.endAngle()());

    // Draw arcs with start-up animations
    chart.selectAll("path")
    .data(arcData)
    .join("path")
        .attr("fill", (d) => color(d.data.key))
        .attr("stroke", "white")
        .style("stroke-width", "1px")
        // Setup mouse enter event trigger
        .on("mouseenter", function (_ignore, d) {
            // Show hidden key and value texts of selected arc
            chart.selectAll(`.text-${group}`)
                .filter((e) => e.data.key === d.data.key)
                    .transition(`text-${group}`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 1);
            // Fade all non-selected arcs
            chart.selectAll("path")
                .filter((e) => e.data.key !== d.data.key)
                    .transition(`arc-${group}`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 0.2);
        })
        // Setup mouse leave event trigger
        .on("mouseleave", function (_ignore, d) {
            // Hide key and value texts of selected arc
            chart.selectAll(`.text-${group}`)
                .filter((e) => e.data.key === d.data.key)
                    .transition(`text-${group}`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 0);
            // Unfade non-selected arcs
            chart.selectAll("path")
                .filter((e) => e.data.key !== d.data.key)
                    .transition(`arc-${group}`)
                    .delay(30) // Prevent flashing
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 1);
        })
        // Draw arcs around a forming circle 
        .transition("arcBuilding")
        .ease(d3.easeCubicOut)
        .duration(1000)
            .attrTween("d", function(d) {
                const endAngle = d.endAngle;
                // Interpolate current angle thru whole pie
                // Draw arc when > start angle, and stop expanding when > end angle
                return function(t) {
                    let currentAngle = angleInterpolate(t);
                    if (currentAngle < d.startAngle) {
                        return "";
                    }
                    d.endAngle = Math.min(currentAngle, endAngle);
                    return arcGenerator(d);
                };
            });
    
    // Add hidden key texts
    chart.selectAll("key")
    .data(arcData)
    .join("text")
        .text((d) => d.data.key)
        .attr("transform", `translate(0 -${radius / 10})`)
        .style("text-anchor", "middle")
        .style("font-size", "36px")
        .attr("opacity", 0)
        .attr("class", `text-${group}`);
    
    // Add hidden value texts
    chart.selectAll("key")
    .data(arcData)
    .join("text")
        .text((d) => d.value.toLocaleString())
        .attr("transform", `translate(0 ${radius / 5})`)
        .style("text-anchor", "middle")
        .style("font-size", "48px")
        .attr("opacity", 0)
        .attr("class", `text-${group}`);
}


// Build bar charts in Summary View
function buildBarChart(data, group) {
    const container = document.querySelector(`#summary-view-${group}-chart`);

    // Set dimension of the chart
    const margin = {top: 30, right: 10, bottom: 70, left: 60},
    width = 800 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

    // Prepare data for d3.js consumption
    let dataArr = [];

    // For year of collection, build bars for the whole range and fill in missing ones with 0
    if (group === "year_of_collection") {
        const dataNums = Object.keys(data).filter((x) => !isNaN(x));
        const dataNumsMin = Math.min(...dataNums);
        const dataNumsMax = Math.max(...dataNums);

        for (let i = dataNumsMin; i <= dataNumsMax; i++) {
            dataArr.push({ key: i, value: data[i] ?? 0 });
        }

        // Uncomment below line to show unknown year of collection
        // if (Object.keys(data).filter((x) => isNaN(x)).length) { dataArr.push({ key: "Unknown", value: data.NaN }); }

    // For age, build bars according to provided bins
    } else if (group === "age"){
        for (const [key, val] of Object.entries(data)) {
            // Comment out below line to show unknown age
            if (key === "NaN") { continue; }

            dataArr.push({ key: key, value: val });
        }
    }

    // Select svg container
    const svgContainer = d3.select(container);

    // Add svg into container
    const svg = svgContainer.append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
    
    // Add chart area in svg
    const chart = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Setup X-axis band scale
    const xScale = d3.scaleBand()
        .range([0, width])
        .domain(dataArr.map((d) => d.key))
        .padding(0.1);
    
    // Setup Y-axis linear scale, the upper limit is rounded up
    const yScale = d3.scaleLinear()
        .domain([0, roundUp(Math.max(...Object.values(data)))])
        .range([height, 0]);

    // Add X-axis and labels
    chart.append("g")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xScale))
        .selectAll("text")
            .style("font-size", "16px")
            .style("text-anchor", "end")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .attr("class", `label-${group}`);

    // Add Y-axis grid lines and labels
    chart.append("g")
        .call(d3.axisLeft(yScale).ticks(5).tickSize(-width))
        .selectAll("text")
            .style("font-size", "16px");

    // Change Y-axis grid line opacity
    chart.selectAll(".tick line")
        .attr("opacity", 0.5);

    // Remove domain lines 
    chart.selectAll(".domain").remove();
    
    // Draw bars with load animations
    chart.selectAll("bar")
    .data(dataArr)
    .join("rect")
        .attr("x", (d) => xScale(d.key))
        .attr("width", xScale.bandwidth())
        .attr("fill", "#633AB5")
        .attr("class", `bar-${group}`)
        // Grow individual bars from 0 height in 300 ms, delay start to progress from left to right across 1000 ms
        .transition(`${group}-growbar`)
        .delay((_ignore,i) => i*1000/dataArr.length)
        .ease(d3.easeCubicOut)
        .duration(300)
            .attrTween("y", function (d) {
                return function (t) {
                    const yInterpolate = d3.interpolate(yScale(0), yScale(d.value));
                    return yInterpolate(t);
                };
            })
            .attrTween("height", function (d) {
                return function (t) {
                    const heightInterpolate = d3.interpolate(height - yScale(0), height - yScale(d.value));
                    return heightInterpolate(t);
                };
            });

    // Add hidden values at the top of bars
    chart.selectAll("value")
    .data(dataArr)
    .join("text")
        .text((d) => d.value)
        .style("font-size", "16px")
        .style("text-anchor", "middle")
        .attr("x", (d) => xScale(d.key) + xScale.bandwidth() / 2)
        .attr("y", (d) => yScale(d.value) - 15)
        .attr("opacity", 0)
        .attr("class", `value-${group}`);
    
    // Add selection zones for the whole height. Add interactivity and animations to the zones
    chart.selectAll("selectionZone")
    .data(dataArr)
    .join("rect")
        .attr("x", (d) => xScale(d.key))
        .attr("y", 0)
        .attr("width", xScale.bandwidth() + xScale.padding() * xScale.step() * 2) // Extra width to fill the gap
        .attr("height", height + margin.bottom)
        .attr("opacity", 0)
        // Setup mouse enter event trigger
        .on("mouseenter", function (_ignore, d) {
            // Show hidden value of the selected column
            chart.selectAll(`.value-${group}`)
                .filter((e) => e.key === d.key)
                    .transition(`value-${group}`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 1)
                        .style("font-size", "24px");
            // Highlight label of the selected column
            chart.selectAll(`.label-${group}`)
                .filter((e) => e === d.key)
                    .transition(`label-${group}-highlight`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .style("font-size", "24px");
            // Fade all non-selected bars
            chart.selectAll(`.bar-${group}`)
                .filter((e) => e.key !== d.key)
                    .transition(`bar-${group}`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 0.2);
            // Fade labels of all non-selected columns
            chart.selectAll(`.label-${group}`)
                .filter((e) => e !== d.key)
                    .transition(`label-${group}-fade`)
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .style('opacity', 0.2);
        })
        // Setup mouse leave event trigger
        .on("mouseleave", function (_ignore, d) {
            // Hide hidden value of the selected column
            chart.selectAll(`.value-${group}`)
                .filter((e) => e.key === d.key)
                    .transition(`value-${group}`)
                    .delay(30) // Prevent flashing
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 0)
                        .style("font-size", "16px");
            // Unhighlight label of the selected column
            chart.selectAll(`.label-${group}`)
                .filter((e) => e === d.key)
                    .transition(`label-${group}-highlight`)
                    .delay(30) // Prevent flashing
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .style("font-size", "16px");
            // Unfade all non-selected bars
            chart.selectAll(`.bar-${group}`)
                .filter((e) => e.key !== d.key)
                    .transition(`bar-${group}`)
                    .delay(30) // Prevent flashing
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .attr("opacity", 1);
            // Unfade labels of all non-selected columns
            chart.selectAll(`.label-${group}`)
                .filter((e) => e !== d.key)
                    .transition(`label-${group}-fade`)
                    .delay(30) // Prevent flashing
                    .duration(selectTransitTime)
                    .ease(d3.easeLinear)
                        .style('opacity', 1);
        });
}

// Build stacked bar charts in Country View
function buildStackedChart(data, type) {
    const container = document.querySelector("#by-country-view-details-content-chart");

    // Clear container
    container.innerHTML = "";

    // Set dimension of the chart
    const margin = {top: 80, right: 200, bottom: 70, left: 60},
    width = 1000 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

    // Select svg container
    const svgContainer = d3.select(container);

    // Add svg into container
    const svg = svgContainer.append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
    
    // Add chart area in svg
    const chart = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Setup color scale
    const color = d3.scaleOrdinal(d3.schemeTableau10);

    // Save all collection years
    let groupSet = new Set();
    // Save all data key
    let keySet = new Set();

    // Prepare data for d3.js consumption
    let dataArr = [];
    // Save max sum of values among all collection years
    let maxSum = 0;

    // Loop through all collection years
    for (const [group, keys] of Object.entries(data[type])) {
        // Comment out below "if block" to include samples with unknown collection year
        if (group === "NaN") { continue; }

        groupSet.add(group);
        let dataArrEle = {group: group};
        let curSum = 0;
        // Loop through all data keys and values in that year
        for (let [key, val] of Object.entries(keys)) {
            if (key === "NaN") {
                key = "Unknown";
            }
            keySet.add(key);
            dataArrEle[key] = val;
            curSum += val;
        }
        dataArr.push(dataArrEle);
        maxSum = Math.max(maxSum, curSum);
    }

    // Early termination for country without sample in the data prepared for d3.js 
    if (dataArr.length === 0) {
        chart.append("text")             
            .attr("transform", `translate(${width/2}, ${height/2})`)
            .style("text-anchor", "middle")
            .text("No samples with a known collection year");
        return;
    }

    // Setup X-axis band scale
    const xScale = d3.scaleBand()
        .range([0, width])
        .domain(groupSet)
        .padding(0.1);
    
    // Round up max sum and at least 10
    const maxSumUp = Math.max(roundUp(maxSum), 10);

    // Setup Y-axis linear scale
    const yScale = d3.scaleLinear()
        .domain([0, maxSumUp])
        .range([height, 0]);

    // Add X-axis and labels
    chart.append("g")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xScale).tickSizeOuter(0))
        .selectAll("text")
            .style("font-size", "12px")
            .attr("transform", "translate(-10,10)rotate(-45)")
            .attr("class", `label-${type}`);
    
    // Add X-axis label
    chart.append("text")             
        .attr("transform", `translate(${width/2}, ${height + margin.top - 20})`)
        .style("text-anchor", "middle")
        .text("Year of Collection");

    // Add Y-axis grid lines and labels
    chart.append("g")
        .call(d3.axisLeft(yScale).ticks(5).tickSize(-width));
    
    // Remove domain lines 
    chart.selectAll(".domain").remove();

    // Add hint
    let hint = chart.append("text")             
        .attr("transform", `translate(${width + margin.right/2}, ${height/2})`)
        .style("text-anchor", "middle")
        .style("fill", "#D3D3D3")
        .text("Hover for details");

    // Stack Generator
    let stackGenerator = d3.stack()
        .keys(keySet)
        .value((d, key) => d[key] ?? 0);

    // Pass dataArr into Stack Generator
    let stackData = stackGenerator(dataArr);

    // Draw bars with start-up animations
    chart.append("g")
        .selectAll("g")
        // Loop through data key
        .data(stackData)
        .join("g")
            .attr("fill", (d) => color(d.key))
        .selectAll("rect")
        // Loop through collection years
        .data((d) => d)
        .join("rect")
            .attr("x", (d) => xScale(d.data.group))
            .attr("width",xScale.bandwidth())
            .attr("class", `subbar-${type}`)
            // Grow individual subbars from 0 height in 300 ms, delay start to progress from left to right across 1000 ms
            .transition("growStackBar")
            .delay((_ignore,i) => i*1000/dataArr.length)
            .ease(d3.easeCubicOut)
            .duration(300)
                .attrTween("y", function (d) {
                    return function (t) {
                        const yInterpolate = d3.interpolate(height, yScale(d[1]));
                        return yInterpolate(t);
                    };
                })
                .attrTween("height", function (d) {
                    return function (t) {
                        const heightInterpolate = d3.interpolate(0, yScale(d[0]) - yScale(d[1]));
                        return heightInterpolate(t);
                    };
                });
    
    // Add selection zones for the whole height. Add interactivity and animations to the zones
    chart.append("g")
        .selectAll("g")
        // Loop through data key
        .data(stackData)
        .join("g")
            .attr("opacity", 0)
        .selectAll("selectionZone")
        // Loop through collection years
        .data((d) => d)
        .join("rect")
            .attr("x", (d) => xScale(d.data.group))
            .attr("y", 0)
            .attr("width", xScale.bandwidth() + xScale.padding() * xScale.step() * 2) // Extra width to fill the gap
            .attr("height", height + 20)
            // Setup mouse enter event trigger
            .on("mouseenter", function (_ignore, d) {
                // Highlight label of the selected column
                chart.selectAll(`.label-${type}`)
                    .filter((e) => e === d.data.group)
                        .transition(`label-${type}-font`)
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .style("font-size", "16px");
                // Fade all non-selected bars
                chart.selectAll(`.subbar-${type}`)
                    .filter((e) => e.data.group !== d.data.group)
                        .transition(`subbar-${type}`)
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .attr("opacity", 0.2);
                // Fade label of non-selected columns
                chart.selectAll(`.label-${type}`)
                    .filter((e) => e !== d.data.group)
                        .transition(`label-${type}-opacity`)
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .attr("opacity", 0.2);
                // Fade hint at legend
                hint
                    .transition("hint")
                    .duration(selectTransitTime)
                    .style("opacity", 0);
                
                // Insert year of collection to legend and fade in
                chart.append("text")             
                    .attr("transform", `translate(${width + margin.right/2}, 0)`)
                    .attr("class", `legend-${type}`)
                    .style("text-anchor", "middle")
                    .style("opacity", 0)
                    .text(d.data.group)
                    .transition(`legend-${type}`)
                    .duration(selectTransitTime)
                        .style("opacity", 1);

                // Count keys with non-zero value
                let i = 0;
                // Reverse order to match stacked bar arrangement
                for (const [key, val] of Object.entries(d.data).reverse()) {
                    // Skip year of collection key and keys with 0 value
                    if (key === "group" | val === 0) { continue; }
                    
                    // i only progress when legend is added
                    i += 1;

                    // Insert colored circle to legend
                    chart.append("circle")
                        .attr("r", 5)
                        .attr("cx", width + 20)
                        .attr("cy", i * 20 + 20)
                        .attr("fill", color(key))
                        .attr("class", `legend-${type}`)
                        .style("opacity", 0)
                        .transition(`legend-${type}`)
                        .duration(selectTransitTime)
                            .style("opacity", 1);
                    // Insert key to legend
                    chart.append("text")
                        .attr("transform", `translate(${width + 40}, ${i * 20 + 25})`)
                        .attr("class", `legend-${type}`)
                        .style("opacity", 0)
                        .style("font-size", "14px")
                        .text(key)
                        .transition(`legend-${type}`)
                        .duration(selectTransitTime)
                            .style("opacity", 1);
                    // Insert value to legend
                    chart.append("text")
                        .attr("transform", `translate(${width + margin.right}, ${i * 20 + 25})`)
                        .attr("class", `legend-${type}`)
                        .style("opacity", 0)
                        .style("text-anchor", "end")
                        .style("font-size", "14px")
                        .text(val.toLocaleString())
                        .transition(`legend-${type}`)
                        .duration(selectTransitTime)
                            .style("opacity", 1);
                }
                // If no legend is inserted, insert "No samples"
                if (i == 0) {
                    chart.append("text")
                        .attr("transform", `translate(${width + margin.right/2}, 45)`)
                        .attr("class", `legend-${type}`)
                        .style("text-anchor", "middle")
                        .style("opacity", 0)
                        .style("font-size", "14px")
                        .text("No samples")
                        .transition(`legend-${type}`)
                        .duration(selectTransitTime)
                            .style("opacity", 1);
                }
            })
            // Setup mouse leave event trigger
            .on("mouseleave", function (_ignore, d) {
                // Unhighlight label of the selected column
                chart.selectAll(`.label-${type}`)
                    .filter((e) => e === (d.data.group))
                        .transition(`label-${type}-font`)
                        .delay(30) // Prevent flashing
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .style("font-size", "12px");
                // Unfade all non-selected bars
                chart.selectAll(`.subbar-${type}`)
                    .filter((e) => e.data.group !== d.data.group)
                        .transition(`subbar-${type}`)
                        .delay(30) // Prevent flashing
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .attr("opacity", 1);
                // Unfade label of non-selected columns
                chart.selectAll(`.label-${type}`)
                    .filter((e) => e !== (d.data.group))
                        .transition(`label-${type}-opacity`)
                        .delay(30) // Prevent flashing
                        .duration(selectTransitTime)
                        .ease(d3.easeLinear)
                            .attr("opacity", 1);
                // Unfade hint at legend
                hint
                    .transition("hint")
                    .duration(selectTransitTime)
                        .style("opacity", 1);
                // Fade out legends and remove
                chart.selectAll(`.legend-${type}`)
                    .transition(`legend-${type}`)
                    .duration(selectTransitTime)
                        .style("opacity", 0)
                        .remove();
            });

    // Setup color scale for vaccine period highlights
    const vaccineColor = d3.scaleOrdinal()
        .domain(["Pre-PCV", "Post-PCV7", "Post-PCV10", "Post-PCV13"])
        .range(d3.schemeSet3);

    // Add vaccine period labels, highlights and separators
    for (const [i, [range, period]] of Object.entries(data.vaccine_period).entries()) {
        const rangeArr = range.split(",");

        // Interpolate from left to right of chart
        const lineInterpolate = d3.interpolate(0, width);

        // Add vaccine period labels with start-up animation
        chart.append("text")
            .text(period)
            .style("font-size", "12px")
            .style("text-anchor", "start")
            .attr("transform", `translate(${xScale(rangeArr[0]) + 5},-15)rotate(-20)`)
            // Fade in when vaccine period highlights approch the position
            .transition(`periodLabel-${type}`)
            .duration(1000)
                .attrTween("opacity", function() {
                    return function(t) {
                        let current = lineInterpolate(t);
                        if (current < xScale(rangeArr[0])) {
                            return 0;
                        } else {
                            return Math.min((current - xScale(rangeArr[0])) / xScale.bandwidth(), 1);
                        }
                    };
                });

        // Add vaccine period highlights with start-up animations
        chart.append("line")
            .attr("x1", xScale(rangeArr[0]))
            .attr("y1", -10)
            .attr("x2", xScale(rangeArr[1]) + xScale.bandwidth())
            .attr("y2", -10)
            .style("stroke-width", 3)
            .style("stroke", vaccineColor(period))
            // Draw lines from left to right
            .transition(`periodLine-${type}`)
            .duration(1000)
                .attrTween("x2", function() {
                    return function(t) {
                        let current = lineInterpolate(t);
                        if (current < xScale(rangeArr[0])) {
                            return xScale(rangeArr[0]);
                        } else {
                            return Math.min(current, xScale(rangeArr[1]) + xScale.bandwidth());
                        }
                    };
                });

        // Skip adding separator if this is the last period
        if (i === Object.keys(data.vaccine_period).length - 1) { continue; }
        
        // Add separator at the end of each period with start-up animations
        const paddingSize = xScale.padding() * xScale.step();
        chart.append("line")
            .attr("x1", xScale(rangeArr[1]) + xScale.bandwidth() + paddingSize / 2)
            .attr("y1", -margin.top/4)
            .attr("x2", xScale(rangeArr[1]) + xScale.bandwidth() + paddingSize / 2)
            .attr("y2", height)
            .style("stroke-width", 1)
            .style("stroke-dasharray", ("3,3"))
            .style("stroke", "black")
            // Fade in when vaccine period highlights approch the position
            .transition("showPeriodSeparator")
            .duration(1000)
                .attrTween("opacity", function() {
                    return function(t) {
                        let current = lineInterpolate(t);
                        if (current < xScale(rangeArr[1])) {
                            return 0;
                        } else {
                            return Math.min((current - xScale(rangeArr[1])) / xScale.bandwidth(), 0.5);
                        }
                    };
                });

    }
}

// Round up to nearest tens/hundreds/thousnds of the same magnitude
function roundUp(n) {
    return Math.pow(10, Math.floor(Math.log10(n))) * (Number(String(n)[0]) + 1);
}